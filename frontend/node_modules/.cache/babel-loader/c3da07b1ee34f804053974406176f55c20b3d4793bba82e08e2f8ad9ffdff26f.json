{"ast":null,"code":"import{useState,useEffect,useCallback,useRef}from'react';// Cache to store data and timestamps\nconst cache=new Map();const CACHE_DURATION=30000;// 30 seconds cache duration\nexport const useRealtimeUpdates=function(){let initialData=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;let fetchFunction=arguments.length>1?arguments[1]:undefined;let interval=arguments.length>2&&arguments[2]!==undefined?arguments[2]:30000;const[data,setData]=useState(initialData);const[loading,setLoading]=useState(true);const[error,setError]=useState('');const retryCount=useRef(0);const maxRetries=3;const baseDelay=1000;// 1 second base delay\nconst lastFetchTime=useRef(0);const minTimeBetweenRequests=5000;// Minimum 5 seconds between requests\nconst getCacheKey=useCallback(()=>{// Create a unique cache key based on the function name and arguments\nreturn fetchFunction.toString();},[fetchFunction]);const fetchData=useCallback(async function(){let force=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;const now=Date.now();const cacheKey=getCacheKey();const cachedData=cache.get(cacheKey);// Check if we have valid cached data and it's not a forced refresh\nif(!force&&cachedData&&now-cachedData.timestamp<CACHE_DURATION){setData(cachedData.data);setLoading(false);return;}// Check if we're making requests too frequently\nif(now-lastFetchTime.current<minTimeBetweenRequests){console.log('Throttling request - too soon since last fetch');return;}try{setError('');lastFetchTime.current=now;const result=await fetchFunction();// Update cache\ncache.set(cacheKey,{data:result,timestamp:now});setData(result);retryCount.current=0;}catch(err){console.error('Error fetching data:',err);if(retryCount.current<maxRetries){const delay=baseDelay*Math.pow(2,retryCount.current);retryCount.current+=1;console.log(\"Retrying in \".concat(delay,\"ms (attempt \").concat(retryCount.current,\"/\").concat(maxRetries,\")\"));setTimeout(()=>fetchData(true),delay);}else{setError(err.message||'Failed to fetch data after multiple attempts');retryCount.current=0;}}finally{setLoading(false);}},[fetchFunction,getCacheKey]);useEffect(()=>{let timeoutId;let isMounted=true;const scheduleNextFetch=()=>{if(isMounted){timeoutId=setTimeout(()=>{fetchData().finally(()=>{if(isMounted){scheduleNextFetch();}});},interval);}};// Initial fetch\nfetchData().finally(()=>{if(isMounted){scheduleNextFetch();}});return()=>{isMounted=false;if(timeoutId){clearTimeout(timeoutId);}};},[fetchData,interval]);// Function to force a refresh\nconst forceRefresh=useCallback(()=>{fetchData(true);},[fetchData]);return{data,loading,error,refetch:forceRefresh};};","map":{"version":3,"names":["useState","useEffect","useCallback","useRef","cache","Map","CACHE_DURATION","useRealtimeUpdates","initialData","arguments","length","undefined","fetchFunction","interval","data","setData","loading","setLoading","error","setError","retryCount","maxRetries","baseDelay","lastFetchTime","minTimeBetweenRequests","getCacheKey","toString","fetchData","force","now","Date","cacheKey","cachedData","get","timestamp","current","console","log","result","set","err","delay","Math","pow","concat","setTimeout","message","timeoutId","isMounted","scheduleNextFetch","finally","clearTimeout","forceRefresh","refetch"],"sources":["C:/Users/RC_Student_lab/Desktop/goon/frontend/src/hooks/useRealtimeUpdates.js"],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\r\n\r\n// Cache to store data and timestamps\r\nconst cache = new Map();\r\nconst CACHE_DURATION = 30000; // 30 seconds cache duration\r\n\r\nexport const useRealtimeUpdates = (initialData = null, fetchFunction, interval = 30000) => {\r\n  const [data, setData] = useState(initialData);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState('');\r\n  const retryCount = useRef(0);\r\n  const maxRetries = 3;\r\n  const baseDelay = 1000; // 1 second base delay\r\n  const lastFetchTime = useRef(0);\r\n  const minTimeBetweenRequests = 5000; // Minimum 5 seconds between requests\r\n\r\n  const getCacheKey = useCallback(() => {\r\n    // Create a unique cache key based on the function name and arguments\r\n    return fetchFunction.toString();\r\n  }, [fetchFunction]);\r\n\r\n  const fetchData = useCallback(async (force = false) => {\r\n    const now = Date.now();\r\n    const cacheKey = getCacheKey();\r\n    const cachedData = cache.get(cacheKey);\r\n\r\n    // Check if we have valid cached data and it's not a forced refresh\r\n    if (!force && cachedData && (now - cachedData.timestamp) < CACHE_DURATION) {\r\n      setData(cachedData.data);\r\n      setLoading(false);\r\n      return;\r\n    }\r\n\r\n    // Check if we're making requests too frequently\r\n    if (now - lastFetchTime.current < minTimeBetweenRequests) {\r\n      console.log('Throttling request - too soon since last fetch');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setError('');\r\n      lastFetchTime.current = now;\r\n      const result = await fetchFunction();\r\n      \r\n      // Update cache\r\n      cache.set(cacheKey, {\r\n        data: result,\r\n        timestamp: now\r\n      });\r\n      \r\n      setData(result);\r\n      retryCount.current = 0;\r\n    } catch (err) {\r\n      console.error('Error fetching data:', err);\r\n      \r\n      if (retryCount.current < maxRetries) {\r\n        const delay = baseDelay * Math.pow(2, retryCount.current);\r\n        retryCount.current += 1;\r\n        \r\n        console.log(`Retrying in ${delay}ms (attempt ${retryCount.current}/${maxRetries})`);\r\n        setTimeout(() => fetchData(true), delay);\r\n      } else {\r\n        setError(err.message || 'Failed to fetch data after multiple attempts');\r\n        retryCount.current = 0;\r\n      }\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [fetchFunction, getCacheKey]);\r\n\r\n  useEffect(() => {\r\n    let timeoutId;\r\n    let isMounted = true;\r\n\r\n    const scheduleNextFetch = () => {\r\n      if (isMounted) {\r\n        timeoutId = setTimeout(() => {\r\n          fetchData().finally(() => {\r\n            if (isMounted) {\r\n              scheduleNextFetch();\r\n            }\r\n          });\r\n        }, interval);\r\n      }\r\n    };\r\n\r\n    // Initial fetch\r\n    fetchData().finally(() => {\r\n      if (isMounted) {\r\n        scheduleNextFetch();\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      isMounted = false;\r\n      if (timeoutId) {\r\n        clearTimeout(timeoutId);\r\n      }\r\n    };\r\n  }, [fetchData, interval]);\r\n\r\n  // Function to force a refresh\r\n  const forceRefresh = useCallback(() => {\r\n    fetchData(true);\r\n  }, [fetchData]);\r\n\r\n  return { data, loading, error, refetch: forceRefresh };\r\n}; "],"mappings":"AAAA,OAASA,QAAQ,CAAEC,SAAS,CAAEC,WAAW,CAAEC,MAAM,KAAQ,OAAO,CAEhE;AACA,KAAM,CAAAC,KAAK,CAAG,GAAI,CAAAC,GAAG,CAAC,CAAC,CACvB,KAAM,CAAAC,cAAc,CAAG,KAAK,CAAE;AAE9B,MAAO,MAAM,CAAAC,kBAAkB,CAAG,QAAAA,CAAA,CAAyD,IAAxD,CAAAC,WAAW,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,IAAI,IAAE,CAAAG,aAAa,CAAAH,SAAA,CAAAC,MAAA,GAAAD,SAAA,IAAAE,SAAA,IAAE,CAAAE,QAAQ,CAAAJ,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,KAAK,CACpF,KAAM,CAACK,IAAI,CAAEC,OAAO,CAAC,CAAGf,QAAQ,CAACQ,WAAW,CAAC,CAC7C,KAAM,CAACQ,OAAO,CAAEC,UAAU,CAAC,CAAGjB,QAAQ,CAAC,IAAI,CAAC,CAC5C,KAAM,CAACkB,KAAK,CAAEC,QAAQ,CAAC,CAAGnB,QAAQ,CAAC,EAAE,CAAC,CACtC,KAAM,CAAAoB,UAAU,CAAGjB,MAAM,CAAC,CAAC,CAAC,CAC5B,KAAM,CAAAkB,UAAU,CAAG,CAAC,CACpB,KAAM,CAAAC,SAAS,CAAG,IAAI,CAAE;AACxB,KAAM,CAAAC,aAAa,CAAGpB,MAAM,CAAC,CAAC,CAAC,CAC/B,KAAM,CAAAqB,sBAAsB,CAAG,IAAI,CAAE;AAErC,KAAM,CAAAC,WAAW,CAAGvB,WAAW,CAAC,IAAM,CACpC;AACA,MAAO,CAAAU,aAAa,CAACc,QAAQ,CAAC,CAAC,CACjC,CAAC,CAAE,CAACd,aAAa,CAAC,CAAC,CAEnB,KAAM,CAAAe,SAAS,CAAGzB,WAAW,CAAC,gBAAyB,IAAlB,CAAA0B,KAAK,CAAAnB,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,KAAK,CAChD,KAAM,CAAAoB,GAAG,CAAGC,IAAI,CAACD,GAAG,CAAC,CAAC,CACtB,KAAM,CAAAE,QAAQ,CAAGN,WAAW,CAAC,CAAC,CAC9B,KAAM,CAAAO,UAAU,CAAG5B,KAAK,CAAC6B,GAAG,CAACF,QAAQ,CAAC,CAEtC;AACA,GAAI,CAACH,KAAK,EAAII,UAAU,EAAKH,GAAG,CAAGG,UAAU,CAACE,SAAS,CAAI5B,cAAc,CAAE,CACzES,OAAO,CAACiB,UAAU,CAAClB,IAAI,CAAC,CACxBG,UAAU,CAAC,KAAK,CAAC,CACjB,OACF,CAEA;AACA,GAAIY,GAAG,CAAGN,aAAa,CAACY,OAAO,CAAGX,sBAAsB,CAAE,CACxDY,OAAO,CAACC,GAAG,CAAC,gDAAgD,CAAC,CAC7D,OACF,CAEA,GAAI,CACFlB,QAAQ,CAAC,EAAE,CAAC,CACZI,aAAa,CAACY,OAAO,CAAGN,GAAG,CAC3B,KAAM,CAAAS,MAAM,CAAG,KAAM,CAAA1B,aAAa,CAAC,CAAC,CAEpC;AACAR,KAAK,CAACmC,GAAG,CAACR,QAAQ,CAAE,CAClBjB,IAAI,CAAEwB,MAAM,CACZJ,SAAS,CAAEL,GACb,CAAC,CAAC,CAEFd,OAAO,CAACuB,MAAM,CAAC,CACflB,UAAU,CAACe,OAAO,CAAG,CAAC,CACxB,CAAE,MAAOK,GAAG,CAAE,CACZJ,OAAO,CAAClB,KAAK,CAAC,sBAAsB,CAAEsB,GAAG,CAAC,CAE1C,GAAIpB,UAAU,CAACe,OAAO,CAAGd,UAAU,CAAE,CACnC,KAAM,CAAAoB,KAAK,CAAGnB,SAAS,CAAGoB,IAAI,CAACC,GAAG,CAAC,CAAC,CAAEvB,UAAU,CAACe,OAAO,CAAC,CACzDf,UAAU,CAACe,OAAO,EAAI,CAAC,CAEvBC,OAAO,CAACC,GAAG,gBAAAO,MAAA,CAAgBH,KAAK,iBAAAG,MAAA,CAAexB,UAAU,CAACe,OAAO,MAAAS,MAAA,CAAIvB,UAAU,KAAG,CAAC,CACnFwB,UAAU,CAAC,IAAMlB,SAAS,CAAC,IAAI,CAAC,CAAEc,KAAK,CAAC,CAC1C,CAAC,IAAM,CACLtB,QAAQ,CAACqB,GAAG,CAACM,OAAO,EAAI,8CAA8C,CAAC,CACvE1B,UAAU,CAACe,OAAO,CAAG,CAAC,CACxB,CACF,CAAC,OAAS,CACRlB,UAAU,CAAC,KAAK,CAAC,CACnB,CACF,CAAC,CAAE,CAACL,aAAa,CAAEa,WAAW,CAAC,CAAC,CAEhCxB,SAAS,CAAC,IAAM,CACd,GAAI,CAAA8C,SAAS,CACb,GAAI,CAAAC,SAAS,CAAG,IAAI,CAEpB,KAAM,CAAAC,iBAAiB,CAAGA,CAAA,GAAM,CAC9B,GAAID,SAAS,CAAE,CACbD,SAAS,CAAGF,UAAU,CAAC,IAAM,CAC3BlB,SAAS,CAAC,CAAC,CAACuB,OAAO,CAAC,IAAM,CACxB,GAAIF,SAAS,CAAE,CACbC,iBAAiB,CAAC,CAAC,CACrB,CACF,CAAC,CAAC,CACJ,CAAC,CAAEpC,QAAQ,CAAC,CACd,CACF,CAAC,CAED;AACAc,SAAS,CAAC,CAAC,CAACuB,OAAO,CAAC,IAAM,CACxB,GAAIF,SAAS,CAAE,CACbC,iBAAiB,CAAC,CAAC,CACrB,CACF,CAAC,CAAC,CAEF,MAAO,IAAM,CACXD,SAAS,CAAG,KAAK,CACjB,GAAID,SAAS,CAAE,CACbI,YAAY,CAACJ,SAAS,CAAC,CACzB,CACF,CAAC,CACH,CAAC,CAAE,CAACpB,SAAS,CAAEd,QAAQ,CAAC,CAAC,CAEzB;AACA,KAAM,CAAAuC,YAAY,CAAGlD,WAAW,CAAC,IAAM,CACrCyB,SAAS,CAAC,IAAI,CAAC,CACjB,CAAC,CAAE,CAACA,SAAS,CAAC,CAAC,CAEf,MAAO,CAAEb,IAAI,CAAEE,OAAO,CAAEE,KAAK,CAAEmC,OAAO,CAAED,YAAa,CAAC,CACxD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}